Provide c++11 headers from tr1 include directory and namespace.

Work around weird namespacing bug in gcc-4.2.1 where class ld::Section
conflicts with template mach_o::relocatable::Section by renaming the latter to
MRFSection (could possibly be done using sed from ebuild or avoided by figuring
out, what's actually going on with those namespaces).

--- ld64-236.3/src/ld/InputFiles.h.orig	2015-02-22 00:00:17.000000000 +0100
+++ ld64-236.3/src/ld/InputFiles.h	2015-02-22 00:01:07.000000000 +0100
@@ -46,6 +46,14 @@
 #include <pthread.h>
 #endif
 
+#ifdef __GLIBCXX__
+#include <tr1/unordered_map>
+#define UNORDERED_MAP tr1::unordered_map
+#else
+#include <unordered_map>
+#define UNORDERED_MAP unordered_map
+#endif
+
 #include <vector>
 
 #include "Options.h"
@@ -112,7 +120,7 @@
 	static void					parseWorkerThread(InputFiles *inputFiles);
 	void						startThread(void (*threadFunc)(InputFiles *)) const;
 
-	typedef std::unordered_map<const char*, ld::dylib::File*, CStringHash, CStringEquals>	InstallNameToDylib;
+	typedef std::UNORDERED_MAP<const char*, ld::dylib::File*, CStringHash, CStringEquals>	InstallNameToDylib;
 
 	const Options&				_options;
 	std::vector<ld::File*>		_inputFiles;
--- ld64-236.3/src/ld/ld.cpp.orig	2015-02-22 00:00:18.000000000 +0100
+++ ld64-236.3/src/ld/ld.cpp	2015-02-22 00:01:07.000000000 +0100
@@ -54,7 +54,13 @@
 #include <vector>
 #include <list>
 #include <algorithm>
+#ifdef __GLIBCXX__
+#include <tr1/unordered_map>
+#define UNORDERED_MAP tr1::unordered_map
+#else
 #include <unordered_map>
+#define UNORDERED_MAP unordered_map
+#endif
 #include <cxxabi.h>
 
 #include "Options.h"
@@ -150,7 +156,7 @@
 	struct SectionEquals {
 		bool operator()(const ld::Section* left, const ld::Section* right) const;
 	};
-	typedef std::unordered_map<const ld::Section*, FinalSection*, SectionHash, SectionEquals> SectionInToOut;
+	typedef std::UNORDERED_MAP<const ld::Section*, FinalSection*, SectionHash, SectionEquals> SectionInToOut;
 	
 
 	SectionInToOut			_sectionInToFinalMap;
--- ld64-236.3/src/ld/ld.hpp.orig	2015-02-22 00:00:18.000000000 +0100
+++ ld64-236.3/src/ld/ld.hpp	2015-02-22 00:01:07.000000000 +0100
@@ -32,7 +32,13 @@
 #include <assert.h>
 
 #include <vector>
+#ifdef __GLIBCXX__
+#include <tr1/unordered_set>
+#define UNORDERED_SET tr1::unordered_set
+#else
 #include <unordered_set>
+#define UNORDERED_SET unordered_set
+#endif
 
 #include "configure.h"
 
@@ -846,7 +852,7 @@
 	bool operator()(const char* left, const char* right) const { return (strcmp(left, right) == 0); }
 };
 
-typedef	std::unordered_set<const char*, ld::CStringHash, ld::CStringEquals>  CStringSet;
+typedef	std::UNORDERED_SET<const char*, ld::CStringHash, ld::CStringEquals>  CStringSet;
 
 class Internal
 {
--- ld64-236.3/src/ld/LinkEditClassic.hpp.orig	2015-02-22 00:00:18.000000000 +0100
+++ ld64-236.3/src/ld/LinkEditClassic.hpp	2015-02-22 00:01:07.000000000 +0100
@@ -31,8 +31,13 @@
 #include <limits.h>
 #include <unistd.h>
 
-#include <vector>
+#ifdef __GLIBCXX__
+#include <tr1/unordered_map>
+#define UNORDERED_MAP tr1::unordered_map
+#else
 #include <unordered_map>
+#define UNORDERED_MAP unordered_map
+#endif
 
 #include "Options.h"
 #include "ld.hpp"
@@ -92,7 +97,7 @@
 
 private:
 	enum { kBufferSize = 0x01000000 };
-	typedef std::unordered_map<const char*, int32_t, CStringHash, CStringEquals> StringToOffset;
+	typedef std::UNORDERED_MAP<const char*, int32_t, CStringHash, CStringEquals> StringToOffset;
 
 	const uint32_t							_pointerSize;
 	std::vector<char*>						_fullBuffers;
--- ld64-236.3/src/ld/Options.cpp.orig	2015-02-22 00:00:18.000000000 +0100
+++ ld64-236.3/src/ld/Options.cpp	2015-02-22 00:01:07.000000000 +0100
@@ -4608,7 +4608,7 @@
 
 	// make sure all required exported symbols exist
 	std::vector<const char*> impliedExports;
-	for (NameSet::iterator it=fExportSymbols.regularBegin(); it != fExportSymbols.regularEnd(); ++it) {
+	for (NameSet::const_iterator it=fExportSymbols.regularBegin(); it != fExportSymbols.regularEnd(); ++it) {
 		const char* name = *it;
 		const int len = strlen(name);
 		if ( (strcmp(&name[len-3], ".eh") == 0) || (strncmp(name, ".objc_category_name_", 20) == 0) ) {
@@ -4640,7 +4640,7 @@
 	}
 
 	// make sure all required re-exported symbols exist
-	for (NameSet::iterator it=fReExportSymbols.regularBegin(); it != fReExportSymbols.regularEnd(); ++it) {
+	for (NameSet::const_iterator it=fReExportSymbols.regularBegin(); it != fReExportSymbols.regularEnd(); ++it) {
 		fInitialUndefines.push_back(*it);
 	}
 	
--- ld64-236.3/src/ld/Options.h.orig	2015-02-22 00:00:18.000000000 +0100
+++ ld64-236.3/src/ld/Options.h	2015-02-22 00:01:07.000000000 +0100
@@ -30,8 +30,17 @@
 #include <mach/machine.h>
 
 #include <vector>
+#ifdef __GLIBCXX__
+#include <tr1/unordered_set>
+#include <tr1/unordered_map>
+#define UNORDERED_MAP tr1::unordered_map
+#define UNORDERED_SET tr1::unordered_set
+#else
 #include <unordered_set>
 #include <unordered_map>
+#define UNORDERED_MAP unordered_map
+#define UNORDERED_SET unordered_set
+#endif
 
 #include "ld.hpp"
 #include "Snapshot.h"
@@ -380,8 +389,8 @@
 	const std::vector<SectionRename>& sectionRenames() const { return fSectionRenames; }
 
 private:
-	typedef std::unordered_map<const char*, unsigned int, ld::CStringHash, ld::CStringEquals> NameToOrder;
-	typedef std::unordered_set<const char*, ld::CStringHash, ld::CStringEquals>  NameSet;
+	typedef std::UNORDERED_MAP<const char*, unsigned int, ld::CStringHash, ld::CStringEquals> NameToOrder;
+	typedef std::UNORDERED_SET<const char*, ld::CStringHash, ld::CStringEquals>  NameSet;
 	enum ExportMode { kExportDefault, kExportSome, kDontExportSome };
 	enum LibrarySearchMode { kSearchDylibAndArchiveInEachDir, kSearchAllDirsForDylibsThenAllDirsForArchives };
 	enum InterposeMode { kInterposeNone, kInterposeAllExternal, kInterposeSome };
@@ -393,8 +402,8 @@
 		bool					containsNonWildcard(const char*) const;
 		bool					empty() const			{ return fRegular.empty() && fWildCard.empty(); }
 		bool					hasWildCards() const	{ return !fWildCard.empty(); }
-		NameSet::iterator		regularBegin() const	{ return fRegular.begin(); }
-		NameSet::iterator		regularEnd() const		{ return fRegular.end(); }
+		NameSet::const_iterator		regularBegin() const	{ return fRegular.begin(); }
+		NameSet::const_iterator		regularEnd() const		{ return fRegular.end(); }
 		void					remove(const NameSet&); 
 	private:
 		static bool				hasWildCards(const char*);
--- ld64-236.3/src/ld/OutputFile.cpp.orig	2015-02-22 00:00:18.000000000 +0100
+++ ld64-236.3/src/ld/OutputFile.cpp	2015-02-22 00:01:07.000000000 +0100
@@ -50,7 +50,13 @@
 #include <vector>
 #include <list>
 #include <algorithm>
+#ifdef __GLIBCXX__
+#include <tr1/unordered_set>
+#define UNORDERED_SET tr1::unordered_set
+#else
 #include <unordered_set>
+#define UNORDERED_SET unordered_set
+#endif
 
 #include <CommonCrypto/CommonDigest.h>
 #include <AvailabilityMacros.h>
@@ -5028,7 +5034,7 @@
 	const char* filename = NULL;
 	bool wroteStartSO = false;
 	state.stabs.reserve(atomsNeedingDebugNotes.size()*4);
-	std::unordered_set<const char*, CStringHash, CStringEquals>  seenFiles;
+	std::UNORDERED_SET<const char*, CStringHash, CStringEquals>  seenFiles;
 	for (std::vector<const ld::Atom*>::iterator it=atomsNeedingDebugNotes.begin(); it != atomsNeedingDebugNotes.end(); it++) {
 		const ld::Atom* atom = *it;
 		const ld::File* atomFile = atom->file();
--- ld64-236.3/src/ld/parsers/archive_file.cpp.orig	2015-02-22 00:00:18.000000000 +0100
+++ ld64-236.3/src/ld/parsers/archive_file.cpp	2015-02-22 00:01:07.000000000 +0100
@@ -33,7 +33,13 @@
 #include <set>
 #include <map>
 #include <algorithm>
+#ifdef __GLIBCXX__
+#include <tr1/unordered_map>
+#define UNORDERED_MAP tr1::unordered_map
+#else
 #include <unordered_map>
+#define UNORDERED_MAP unordered_map
+#endif
 
 #include "MachOFileAbstraction.hpp"
 #include "Architectures.hpp"
@@ -116,7 +122,7 @@
 	struct MemberState { ld::relocatable::File* file; const Entry *entry; bool logged; bool loaded; uint32_t index;};
 	bool											loadMember(MemberState& state, ld::File::AtomHandler& handler, const char *format, ...) const;
 
-	typedef std::unordered_map<const char*, const struct ranlib*, ld::CStringHash, ld::CStringEquals> NameToEntryMap;
+	typedef std::UNORDERED_MAP<const char*, const struct ranlib*, ld::CStringHash, ld::CStringEquals> NameToEntryMap;
 
 	typedef typename A::P							P;
 	typedef typename A::P::E						E;
--- ld64-236.3/src/ld/parsers/lto_file.cpp.orig	2014-04-05 00:42:29.000000000 +0200
+++ ld64-236.3/src/ld/parsers/lto_file.cpp	2015-02-22 00:01:07.000000000 +0100
@@ -33,8 +33,17 @@
 #include <pthread.h>
 #include <mach-o/dyld.h>
 #include <vector>
+#ifdef __GLIBCXX__
+#include <tr1/unordered_set>
+#include <tr1/unordered_map>
+#define UNORDERED_MAP tr1::unordered_map
+#define UNORDERED_SET tr1::unordered_set
+#else
 #include <unordered_set>
 #include <unordered_map>
+#define UNORDERED_MAP unordered_map
+#define UNORDERED_SET unordered_set
+#endif
 
 #include "MachOFileAbstraction.hpp"
 #include "Architectures.hpp"
@@ -217,8 +226,8 @@
 	static void ltoDiagnosticHandler(lto_codegen_diagnostic_severity_t, const char*, void*);
 #endif
 
-	typedef	std::unordered_set<const char*, ld::CStringHash, ld::CStringEquals>  CStringSet;
-	typedef std::unordered_map<const char*, Atom*, ld::CStringHash, ld::CStringEquals> CStringToAtom;
+	typedef	std::UNORDERED_SET<const char*, ld::CStringHash, ld::CStringEquals>  CStringSet;
+	typedef std::UNORDERED_MAP<const char*, Atom*, ld::CStringHash, ld::CStringEquals> CStringToAtom;
 	
 	class AtomSyncer : public ld::File::AtomHandler {
 	public:
--- ld64-236.3/src/ld/parsers/macho_dylib_file.cpp.orig	2015-02-22 00:00:18.000000000 +0100
+++ ld64-236.3/src/ld/parsers/macho_dylib_file.cpp	2015-02-22 00:01:07.000000000 +0100
@@ -34,8 +34,17 @@
 #include <vector>
 #include <set>
 #include <algorithm>
-#include <unordered_map>
+#ifdef __GLIBCXX__
+#include <tr1/unordered_set>
+#include <tr1/unordered_map>
+#define UNORDERED_MAP tr1::unordered_map
+#define UNORDERED_SET tr1::unordered_set
+#else
 #include <unordered_set>
+#include <unordered_map>
+#define UNORDERED_MAP unordered_map
+#define UNORDERED_SET unordered_set
+#endif
 
 #include "Architectures.hpp"
 #include "MachOFileAbstraction.hpp"
@@ -189,8 +198,8 @@
 		};
 	};
 	struct AtomAndWeak { ld::Atom* atom; bool weakDef; bool tlv; pint_t address; };
-	typedef std::unordered_map<const char*, AtomAndWeak, ld::CStringHash, ld::CStringEquals> NameToAtomMap;
-	typedef std::unordered_set<const char*, CStringHash, ld::CStringEquals>  NameSet;
+	typedef std::UNORDERED_MAP<const char*, AtomAndWeak, ld::CStringHash, ld::CStringEquals> NameToAtomMap;
+	typedef std::UNORDERED_SET<const char*, CStringHash, ld::CStringEquals>  NameSet;
 
 	struct Dependent { const char* path; File<A>* dylib; bool reExport; };
 
@@ -552,14 +561,18 @@
 		if ( _s_logHashtable ) fprintf(stderr, "ld: building hashtable of %u toc entries for %s\n", dynamicInfo->nextdefsym(), this->path());
 		const macho_nlist<P>* start = &symbolTable[dynamicInfo->iextdefsym()];
 		const macho_nlist<P>* end = &start[dynamicInfo->nextdefsym()];
+#ifndef __GLIBCXX__
 		_atoms.reserve(dynamicInfo->nextdefsym()); // set initial bucket count
+#endif
 		for (const macho_nlist<P>* sym=start; sym < end; ++sym) {
 			this->addSymbol(&strings[sym->n_strx()], (sym->n_desc() & N_WEAK_DEF) != 0, false, sym->n_value());
 		}
 	}
 	else {
 		int32_t count = dynamicInfo->ntoc();
+#ifndef __GLIBCXX__
 		_atoms.reserve(count); // set initial bucket count
+#endif
 		if ( _s_logHashtable ) fprintf(stderr, "ld: building hashtable of %u entries for %s\n", count, this->path());
 		const struct dylib_table_of_contents* toc = (dylib_table_of_contents*)(fileContent + dynamicInfo->tocoff());
 		for (int32_t i = 0; i < count; ++i) {
--- ld64-236.3/src/ld/parsers/macho_relocatable_file.cpp.orig	2015-02-22 00:00:18.000000000 +0100
+++ ld64-236.3/src/ld/parsers/macho_relocatable_file.cpp	2015-02-22 00:01:39.000000000 +0100
@@ -62,7 +62,7 @@
 // forward reference
 template <typename A> class Parser;
 template <typename A> class Atom;
-template <typename A> class Section;
+template <typename A> class MRFSection;
 template <typename A> class CFISection;
 template <typename A> class CUSection;
 
@@ -100,14 +100,14 @@
 	const uint8_t*										fileContent()					{ return _fileContent; }
 private:
 	friend class Atom<A>;
-	friend class Section<A>;
+	friend class MRFSection<A>;
 	friend class Parser<A>;
 	friend class CFISection<A>::OAS;
 	
 	typedef typename A::P					P;
 	
 	const uint8_t*							_fileContent;
-	Section<A>**							_sectionsArray;
+	MRFSection<A>**							_sectionsArray;
 	uint8_t*								_atomsArray;
 	uint32_t								_sectionsArrayCount;
 	uint32_t								_atomsArrayCount;
@@ -129,14 +129,14 @@
 
 
 template <typename A>
-class Section : public ld::Section
+class MRFSection : public ld::Section
 {
 public:
 	typedef typename A::P::uint_t	pint_t;
 	typedef typename A::P			P;
 	typedef typename A::P::E		E;
 
-	virtual							~Section()					{ }
+	virtual							~MRFSection()					{ }
 	class File<A>&					file() const				{ return _file; }
 	const macho_section<P>*			machoSection() const		{ return _machOSection; }
 	uint32_t						sectionNum(class Parser<A>&) const;
@@ -160,10 +160,10 @@
 	static const char*				makeSectionName(const macho_section<typename A::P>* s);
 
 protected:	
-						Section(File<A>& f, const macho_section<typename A::P>* s)
+						MRFSection(File<A>& f, const macho_section<typename A::P>* s)
 							: ld::Section(makeSegmentName(s), makeSectionName(s), sectionType(s)),
 								_file(f), _machOSection(s), _beginAtoms(NULL), _endAtoms(NULL), _hasAliases(false) { }
-						Section(File<A>& f, const char* segName, const char* sectName, ld::Section::Type t, bool hidden=false)
+						MRFSection(File<A>& f, const char* segName, const char* sectName, ld::Section::Type t, bool hidden=false)
 							: ld::Section(segName, sectName, t, hidden), _file(f), _machOSection(NULL), 
 								_beginAtoms(NULL), _endAtoms(NULL), _hasAliases(false) { }
 
@@ -189,11 +189,11 @@
 
 
 template <typename A>
-class CFISection : public Section<A>
+class CFISection : public MRFSection<A>
 {
 public:
 						CFISection(Parser<A>& parser, File<A>& f, const macho_section<typename A::P>* s)
-							: Section<A>(f, s) { }
+							: MRFSection<A>(f, s) { }
 	uint32_t			cfiCount();
 
 	virtual ld::Atom::ContentType	contentType()		{ return ld::Atom::typeCFI; }
@@ -253,11 +253,11 @@
 
 
 template <typename A>
-class CUSection : public Section<A>
+class CUSection : public MRFSection<A>
 {
 public:
 						CUSection(Parser<A>& parser, File<A>& f, const macho_section<typename A::P>* s)
-							: Section<A>(f, s) { }
+							: MRFSection<A>(f, s) { }
 
 	typedef typename A::P::uint_t	pint_t;
 	typedef typename A::P			P;
@@ -294,11 +294,11 @@
 
 
 template <typename A>
-class TentativeDefinitionSection : public Section<A>
+class TentativeDefinitionSection : public MRFSection<A>
 {
 public:
 						TentativeDefinitionSection(Parser<A>& parser, File<A>& f)
-							: Section<A>(f, "__DATA", "__comm/tent", ld::Section::typeTentativeDefs)  {}
+							: MRFSection<A>(f, "__DATA", "__comm/tent", ld::Section::typeTentativeDefs)  {}
 
 	virtual ld::Atom::ContentType	contentType()		{ return ld::Atom::typeZeroFill; }
 	virtual bool		addFollowOnFixups() const	{ return false; }
@@ -316,11 +316,11 @@
 
 
 template <typename A>
-class AbsoluteSymbolSection : public Section<A>
+class AbsoluteSymbolSection : public MRFSection<A>
 {
 public:
 						AbsoluteSymbolSection(Parser<A>& parser, File<A>& f)
-							: Section<A>(f, "__DATA", "__abs", ld::Section::typeAbsoluteSymbols, true)  {}
+							: MRFSection<A>(f, "__DATA", "__abs", ld::Section::typeAbsoluteSymbols, true)  {}
 
 	virtual ld::Atom::ContentType	contentType()		{ return ld::Atom::typeUnclassified; }
 	virtual bool					dontDeadStrip()		{ return false; }
@@ -342,7 +342,7 @@
 
 
 template <typename A>
-class SymboledSection : public Section<A>
+class SymboledSection : public MRFSection<A>
 {
 public:
 						SymboledSection(Parser<A>& parser, File<A>& f, const macho_section<typename A::P>* s);
@@ -374,11 +374,11 @@
 
 
 template <typename A>
-class ImplicitSizeSection : public Section<A>
+class ImplicitSizeSection : public MRFSection<A>
 {
 public:
 						ImplicitSizeSection(Parser<A>& parser, File<A>& f, const macho_section<typename A::P>* s)
-							: Section<A>(f, s) { }
+							: MRFSection<A>(f, s) { }
 	virtual uint32_t	computeAtomCount(class Parser<A>& parser, struct Parser<A>::LabelAndCFIBreakIterator& it, const struct Parser<A>::CFI_CU_InfoArrays&);
 	virtual uint32_t	appendAtoms(class Parser<A>& parser, uint8_t* buffer, struct Parser<A>::LabelAndCFIBreakIterator& it, const struct Parser<A>::CFI_CU_InfoArrays&);
 protected:
@@ -712,8 +712,8 @@
 
 public:
 	// methods for all atoms from mach-o object file
-			Section<A>&							sect() const			{ return (Section<A>&)section(); }
-			File<A>&							machofile() const			{ return ((Section<A>*)(this->_section))->file(); }
+			MRFSection<A>&							sect() const			{ return (MRFSection<A>&)section(); }
+			File<A>&							machofile() const			{ return ((MRFSection<A>*)(this->_section))->file(); }
 			void								setFixupsRange(uint32_t s, uint32_t c);
 			void								setUnwindInfoRange(uint32_t s, uint32_t c);
 			void								extendUnwindInfoRange();
@@ -730,7 +730,7 @@
 	typedef typename A::P::E					E;
 	typedef typename A::P::uint_t				pint_t;
 												// constuct via all attributes
-												Atom(Section<A>& sct, const char* nm, pint_t addr, uint64_t sz, 
+												Atom(MRFSection<A>& sct, const char* nm, pint_t addr, uint64_t sz, 
 													ld::Atom::Definition d, ld::Atom::Combine c, ld::Atom::Scope s, 
 													ld::Atom::ContentType ct, ld::Atom::SymbolTableInclusion i, 
 													bool dds, bool thumb, bool al, ld::Atom::Alignment a) 
@@ -740,7 +740,7 @@
 															_unwindInfoStartIndex(0), _fixupsCount(0),  
 															_lineInfoCount(0), _unwindInfoCount(0) { }
 												// construct via symbol table entry
-												Atom(Section<A>& sct, Parser<A>& parser, const macho_nlist<P>& sym, 
+												Atom(MRFSection<A>& sct, Parser<A>& parser, const macho_nlist<P>& sym, 
 																uint64_t sz, bool alias=false)
 														: ld::Atom((ld::Section&)sct, parser.definitionFromSymbol(sym), 
 																parser.combineFromSymbol(sym), parser.scopeFromSymbol(sym),
@@ -763,7 +763,7 @@
 
 private:
 	friend class Parser<A>;
-	friend class Section<A>;
+	friend class MRFSection<A>;
 	friend class CStringSection<A>;
 	friend class AbsoluteSymbolSection<A>;
 	
@@ -996,8 +996,8 @@
 	uint32_t										undefinedStartIndex() { return _undefinedStartIndex; }
 	uint32_t										undefinedEndIndex() { return _undefinedEndIndex; }
 	void											addFixup(FixupInAtom f) { _allFixups.push_back(f); }
-	Section<A>*										sectionForNum(unsigned int sectNum);
-	Section<A>*										sectionForAddress(pint_t addr);
+	MRFSection<A>*										sectionForNum(unsigned int sectNum);
+	MRFSection<A>*										sectionForAddress(pint_t addr);
 	Atom<A>*										findAtomByAddress(pint_t addr);
 	Atom<A>*										findAtomByAddressOrNullIfStub(pint_t addr);
 	Atom<A>*										findAtomByAddressOrLocalTargetOfStub(pint_t addr, uint32_t* offsetInAtom);
@@ -1039,7 +1039,7 @@
 									: sortedSymbolIndexes(ssa), sortedSymbolCount(ssc), cfiStartsArray(cfisa), 
 										cfiStartsCount(cfisc), fileHasOverlappingSymbols(ols),
 										newSection(false), cfiIndex(0), symIndex(0) {}
-		bool					next(Parser<A>& parser, const Section<A>& sect, uint32_t sectNum, pint_t startAddr, pint_t endAddr, 
+		bool					next(Parser<A>& parser, const MRFSection<A>& sect, uint32_t sectNum, pint_t startAddr, pint_t endAddr, 
 										pint_t* addr, pint_t* size, const macho_nlist<P>** sym);
 		pint_t					peek(Parser<A>& parser, pint_t startAddr, pint_t endAddr);
 		void					beginSection() { newSection = true; symIndex = 0; }
@@ -1068,7 +1068,7 @@
 
 
 private:
-	friend class Section<A>;
+	friend class MRFSection<A>;
 	
 	enum SectionType { sectionTypeIgnore, sectionTypeLiteral4, sectionTypeLiteral8, sectionTypeLiteral16, 
 						sectionTypeNonLazy, sectionTypeCFI, sectionTypeCString, sectionTypeCStringPointer, 
@@ -1481,7 +1481,7 @@
 // was becuase of a label, the symbol). Returns false when no more chunks.
 //
 template <typename A>
-bool Parser<A>::LabelAndCFIBreakIterator::next(Parser<A>& parser, const Section<A>& sect, uint32_t sectNum, pint_t startAddr, pint_t endAddr, 
+bool Parser<A>::LabelAndCFIBreakIterator::next(Parser<A>& parser, const MRFSection<A>& sect, uint32_t sectNum, pint_t startAddr, pint_t endAddr, 
 												pint_t* addr, pint_t* size, const macho_nlist<P>** symbol)
 {
 	// may not be a label on start of section, but need atom demarcation there
@@ -1667,7 +1667,7 @@
 	uint32_t sortedSymbolIndexes[_symbolsInSections];
 	this->makeSortedSymbolsArray(sortedSymbolIndexes, sortedSectionIndexes);
 		
-	// allocate Section<A> object for each mach-o section
+	// allocate MRFSection<A> object for each mach-o section
 	makeSections();
 	
 	// if it exists, do special early parsing of __compact_unwind section
@@ -1764,7 +1764,7 @@
 	#endif	
 	}
 	
-	Section<A>** sections = _file->_sectionsArray;
+	MRFSection<A>** sections = _file->_sectionsArray;
 	uint32_t	sectionsCount = _file->_sectionsArrayCount;
 
 	// figure out how many atoms will be allocated and allocate
@@ -2295,11 +2295,11 @@
 					_file->_objConstraint = ld::File::objcConstraintRetainRelease;
 				if ( sect->size() > 8 ) {
 					warning("section %s/%s has unexpectedly large size %llu in %s", 
-							sect->segname(), Section<A>::makeSectionName(sect), sect->size(), _file->path());
+							sect->segname(), MRFSection<A>::makeSectionName(sect), sect->size(), _file->path());
 				}
 			}
 			else {
-				warning("can't parse %s/%s section in %s", sect->segname(), Section<A>::makeSectionName(sect), _file->path());
+				warning("can't parse %s/%s section in %s", sect->segname(), MRFSection<A>::makeSectionName(sect), _file->path());
 			}
 			continue;
 		}
@@ -2395,24 +2395,24 @@
 	// sort by address (mach-o object files don't aways have sections sorted)
 	::qsort(machOSects, count, sizeof(MachOSectionAndSectionClass<P>), MachOSectionAndSectionClass<P>::sorter);
 		
-	// we will synthesize a dummy Section<A> object for tentative definitions
+	// we will synthesize a dummy MRFSection<A> object for tentative definitions
 	if ( _tentativeDefinitionCount > 0 ) {
 		totalSectionsSize += sizeof(TentativeDefinitionSection<A>);
 		machOSects[count++].type = sectionTypeTentativeDefinitions;
 	}
 	
-	// we will synthesize a dummy Section<A> object for Absolute symbols
+	// we will synthesize a dummy MRFSection<A> object for Absolute symbols
 	if ( _absoluteSymbolCount > 0 ) {
 		totalSectionsSize += sizeof(AbsoluteSymbolSection<A>);
 		machOSects[count++].type = sectionTypeAbsoluteSymbols;
 	}
 
 	// allocate one block for all Section objects as well as pointers to each
-	uint8_t* space = new uint8_t[totalSectionsSize+count*sizeof(Section<A>*)];
-	_file->_sectionsArray = (Section<A>**)space;
+	uint8_t* space = new uint8_t[totalSectionsSize+count*sizeof(MRFSection<A>*)];
+	_file->_sectionsArray = (MRFSection<A>**)space;
 	_file->_sectionsArrayCount = count;
-	Section<A>** objects = _file->_sectionsArray;
-	space += count*sizeof(Section<A>*);
+	MRFSection<A>** objects = _file->_sectionsArray;
+	space += count*sizeof(MRFSection<A>*);
 	for (uint32_t i=0; i < count; ++i) {
 		switch ( machOSects[i].type ) {
 			case sectionTypeIgnore:
@@ -2500,7 +2500,7 @@
 
 
 template <typename A>
-Section<A>* Parser<A>::sectionForAddress(typename A::P::uint_t addr)
+MRFSection<A>* Parser<A>::sectionForAddress(typename A::P::uint_t addr)
 {
 	for (uint32_t i=0; i < _file->_sectionsArrayCount; ++i ) {
 		const macho_section<typename A::P>* sect = _file->_sectionsArray[i]->machoSection();
@@ -2527,7 +2527,7 @@
 }
 
 template <typename A>
-Section<A>* Parser<A>::sectionForNum(unsigned int num)
+MRFSection<A>* Parser<A>::sectionForNum(unsigned int num)
 {
 	for (uint32_t i=0; i < _file->_sectionsArrayCount; ++i ) {
 		const macho_section<typename A::P>* sect = _file->_sectionsArray[i]->machoSection();
@@ -2543,7 +2543,7 @@
 template <typename A>
 Atom<A>* Parser<A>::findAtomByAddress(pint_t addr)
 {
-	Section<A>* section = this->sectionForAddress(addr);
+	MRFSection<A>* section = this->sectionForAddress(addr);
 	return section->findAtomByAddress(addr);
 }
 
@@ -2600,7 +2600,7 @@
 		target.addend = 0;
 		return;
 	}
-	Section<A>* section = this->sectionForAddress(addr);
+	MRFSection<A>* section = this->sectionForAddress(addr);
 	target.atom = section->findAtomByAddress(addr);
 	target.addend = addr - target.atom->_objAddress;
 	target.weakImport = false;
@@ -2648,7 +2648,7 @@
 		}
 		return;
 	}
-	Section<A>* section = this->sectionForNum(sectNum);
+	MRFSection<A>* section = this->sectionForNum(sectNum);
 	target.atom = section->findAtomByAddress(addr);
 	if ( target.atom == NULL ) {
 		typedef typename A::P::sint_t sint_t;
@@ -3821,7 +3821,7 @@
 }
 
 template <typename A>
-const char* Section<A>::makeSegmentName(const macho_section<typename A::P>* sect)
+const char* MRFSection<A>::makeSegmentName(const macho_section<typename A::P>* sect)
 {
 	// mach-o section record only has room for 16-byte seg/sect names
 	// so a 16-byte name has no trailing zero
@@ -3834,7 +3834,7 @@
 }
 
 template <typename A>
-const char* Section<A>::makeSectionName(const macho_section<typename A::P>* sect)
+const char* MRFSection<A>::makeSectionName(const macho_section<typename A::P>* sect)
 {
 	const char* name = sect->sectname();
 	if ( strlen(name) < 16 ) 
@@ -3868,13 +3868,13 @@
 }
 
 template <typename A>
-bool Section<A>::readable(const macho_section<typename A::P>* sect)
+bool MRFSection<A>::readable(const macho_section<typename A::P>* sect)
 {
 	return true;
 }
 
 template <typename A>
-bool Section<A>::writable(const macho_section<typename A::P>* sect)
+bool MRFSection<A>::writable(const macho_section<typename A::P>* sect)
 {
 	// mach-o .o files do not contain segment permissions
 	// we just know TEXT is special
@@ -3882,7 +3882,7 @@
 }
 
 template <typename A>
-bool Section<A>::exectuable(const macho_section<typename A::P>* sect)
+bool MRFSection<A>::exectuable(const macho_section<typename A::P>* sect)
 {
 	// mach-o .o files do not contain segment permissions
 	// we just know TEXT is special
@@ -3891,7 +3891,7 @@
 
 
 template <typename A>
-ld::Section::Type Section<A>::sectionType(const macho_section<typename A::P>* sect)
+ld::Section::Type MRFSection<A>::sectionType(const macho_section<typename A::P>* sect)
 {
 	switch ( sect->flags() & SECTION_TYPE ) {
 		case S_ZEROFILL:
@@ -3969,7 +3969,7 @@
 
 
 template <typename A>
-Atom<A>* Section<A>::findContentAtomByAddress(pint_t addr, class Atom<A>* start, class Atom<A>* end)
+Atom<A>* MRFSection<A>::findContentAtomByAddress(pint_t addr, class Atom<A>* start, class Atom<A>* end)
 {
 	// do a binary search of atom array
 	uint32_t atomCount = end - start;
@@ -4001,7 +4001,7 @@
 }
 
 template <typename A>
-ld::Atom::Alignment Section<A>::alignmentForAddress(pint_t addr) 
+ld::Atom::Alignment MRFSection<A>::alignmentForAddress(pint_t addr) 
 { 
 	const uint32_t sectionAlignment = this->_machOSection->align();
 	uint32_t modulus = (addr % (1 << sectionAlignment));
@@ -4011,7 +4011,7 @@
 }
 
 template <typename A>
-uint32_t Section<A>::sectionNum(class Parser<A>& parser) const	
+uint32_t MRFSection<A>::sectionNum(class Parser<A>& parser) const	
 { 
 	if ( _machOSection == NULL )
 		return 0;
@@ -4656,7 +4656,7 @@
 	else {
 		const pint_t* content = (pint_t*)(this->file().fileContent() + this->_machOSection->offset() + reloc->r_address());
 		pint_t personalityAddr = *content;
-		Section<x86_64>* personalitySection = parser.sectionForAddress(personalityAddr);
+		MRFSection<x86_64>* personalitySection = parser.sectionForAddress(personalityAddr);
 		assert((personalitySection->type() == ld::Section::typeCode) && "personality column in __compact_unwind section is not pointer to function");
 		// atoms may not be constructed yet, so scan symbol table for labels
 		const char* name = parser.scanSymbolTableForAddress(personalityAddr);
@@ -4676,7 +4676,7 @@
 		// support __LD, __compact_unwind personality entries which are pointer to personality non-lazy pointer
 		const pint_t* content = (pint_t*)(this->file().fileContent() + this->_machOSection->offset() + reloc->r_address());
 		pint_t nlPointerAddr = *content;
-		Section<x86>* nlSection = parser.sectionForAddress(nlPointerAddr);
+		MRFSection<x86>* nlSection = parser.sectionForAddress(nlPointerAddr);
 		if ( nlSection->type() == ld::Section::typeCode ) {
 			// personality function is defined in this .o file, so this is a direct reference to it
 			// atoms may not be constructed yet, so scan symbol table for labels
@@ -4703,7 +4703,7 @@
 	else {
 		const pint_t* content = (pint_t*)(this->file().fileContent() + this->_machOSection->offset() + reloc->r_address());
 		pint_t personalityAddr = *content;
-		Section<arm64>* personalitySection = parser.sectionForAddress(personalityAddr);
+		MRFSection<arm64>* personalitySection = parser.sectionForAddress(personalityAddr);
 		assert((personalitySection->type() == ld::Section::typeCode) && "personality column in __compact_unwind section is not pointer to function");
 		// atoms may not be constructed yet, so scan symbol table for labels
 		const char* name = parser.scanSymbolTableForAddress(personalityAddr);
@@ -4874,7 +4874,7 @@
 
 template <typename A>
 SymboledSection<A>::SymboledSection(Parser<A>& parser, File<A>& f, const macho_section<typename A::P>* s)
-	: Section<A>(f, s), _type(ld::Atom::typeUnclassified) 
+	: MRFSection<A>(f, s), _type(ld::Atom::typeUnclassified) 
 {
 	switch ( s->flags() & SECTION_TYPE ) {
 		case S_ZEROFILL:
@@ -4920,7 +4920,7 @@
 			if ( ! this->_file.canScatterAtoms() )
 				return true;
 			// call inherited
-			return Section<A>::dontDeadStrip();
+			return MRFSection<A>::dontDeadStrip();
 	}
 	return false;
 }
@@ -5788,7 +5788,7 @@
 
 
 template <>
-uint32_t Section<x86_64>::x86_64PcRelOffset(uint8_t r_type)
+uint32_t MRFSection<x86_64>::x86_64PcRelOffset(uint8_t r_type)
 {
 	switch ( r_type ) {
 		case X86_64_RELOC_SIGNED:
@@ -5805,7 +5805,7 @@
 
 
 template <>
-bool Section<x86_64>::addRelocFixup(class Parser<x86_64>& parser, const macho_relocation_info<P>* reloc)
+bool MRFSection<x86_64>::addRelocFixup(class Parser<x86_64>& parser, const macho_relocation_info<P>* reloc)
 {
 	const macho_section<P>* sect = this->machoSection();
 	uint64_t srcAddr = sect->addr() + reloc->r_address();
@@ -6012,7 +6012,7 @@
 
 
 template <>
-bool Section<x86>::addRelocFixup(class Parser<x86>& parser, const macho_relocation_info<P>* reloc)
+bool MRFSection<x86>::addRelocFixup(class Parser<x86>& parser, const macho_relocation_info<P>* reloc)
 {
 	const macho_section<P>* sect = this->machoSection();
 	uint32_t srcAddr;
@@ -6254,7 +6254,7 @@
 // ppc and ppc64 both use the same relocations, so process them in one common routine
 //
 template <typename A>
-bool Section<A>::addRelocFixup_powerpc(class Parser<A>& parser,
+bool MRFSection<A>::addRelocFixup_powerpc(class Parser<A>& parser,
 	const macho_relocation_info<typename A::P>* reloc)
 {
 	const macho_section<P>* sect = this->machoSection();
@@ -6640,7 +6640,7 @@
 
 #if SUPPORT_ARCH_ppc
 template <>
-bool Section<ppc>::addRelocFixup(class Parser<ppc>& parser, const macho_relocation_info<P>* reloc)
+bool MRFSection<ppc>::addRelocFixup(class Parser<ppc>& parser, const macho_relocation_info<P>* reloc)
 {
 	return addRelocFixup_powerpc(parser, reloc);
 }
@@ -6649,7 +6649,7 @@
 
 #if SUPPORT_ARCH_ppc64
 template <>
-bool Section<ppc64>::addRelocFixup(class Parser<ppc64>& parser, const macho_relocation_info<P>* reloc)
+bool MRFSection<ppc64>::addRelocFixup(class Parser<ppc64>& parser, const macho_relocation_info<P>* reloc)
 {
 	return addRelocFixup_powerpc(parser, reloc);
 }
@@ -6659,7 +6659,7 @@
 
 #if SUPPORT_ARCH_arm_any
 template <>
-bool Section<arm>::addRelocFixup(class Parser<arm>& parser, const macho_relocation_info<P>* reloc)
+bool MRFSection<arm>::addRelocFixup(class Parser<arm>& parser, const macho_relocation_info<P>* reloc)
 {
 	const macho_section<P>* sect = this->machoSection();
 	bool result = false;
@@ -7117,7 +7117,7 @@
 
 #if SUPPORT_ARCH_arm64
 template <>
-bool Section<arm64>::addRelocFixup(class Parser<arm64>& parser, const macho_relocation_info<P>* reloc)
+bool MRFSection<arm64>::addRelocFixup(class Parser<arm64>& parser, const macho_relocation_info<P>* reloc)
 {
 	bool result = false;
 	Parser<arm64>::SourceLocation	src;
@@ -7586,7 +7586,7 @@
 
 #if SUPPORT_ARCH_arm64
 template <>
-void Section<arm64>::addLOH(class Parser<arm64>& parser, int kind, int count, const uint64_t addrs[]) {
+void MRFSection<arm64>::addLOH(class Parser<arm64>& parser, int kind, int count, const uint64_t addrs[]) {
 	switch (kind) {
 		case LOH_ARM64_ADRP_ADRP:
 		case LOH_ARM64_ADRP_LDR:
@@ -7641,18 +7641,18 @@
 	extra.info.delta2 = (count > 1) ? ((addrs[1] - lowestAddress) >> 2) : 0;
 	extra.info.delta3 = (count > 2) ? ((addrs[2] - lowestAddress) >> 2) : 0;
 	extra.info.delta4 = (count > 3) ? ((addrs[3] - lowestAddress) >> 2) : 0;
-	typename Parser<arm64>::SourceLocation src(inAtom, lowestAddress- inAtom->objectAddress());
+	Parser<arm64>::SourceLocation src(inAtom, lowestAddress- inAtom->objectAddress());
 	parser.addFixup(src, ld::Fixup::k1of1, ld::Fixup::kindLinkerOptimizationHint, extra.addend);
 }
 #endif
 
 template <typename A>
-void Section<A>::addLOH(class Parser<A>& parser, int kind, int count, const uint64_t addrs[]) {
+void MRFSection<A>::addLOH(class Parser<A>& parser, int kind, int count, const uint64_t addrs[]) {
 
 }
 
 template <typename A>
-void Section<A>::makeFixups(class Parser<A>& parser, const struct Parser<A>::CFI_CU_InfoArrays&)
+void MRFSection<A>::makeFixups(class Parser<A>& parser, const struct Parser<A>::CFI_CU_InfoArrays&)
 {
 	const macho_section<P>* sect = this->machoSection();
 	const macho_relocation_info<P>* relocs = (macho_relocation_info<P>*)(file().fileContent() + sect->reloff());
@@ -7663,7 +7663,7 @@
 				++r; // skip next
 		}
 		catch (const char* msg) {
-			throwf("in section %s,%s reloc %u: %s", sect->segname(), Section<A>::makeSectionName(sect), r, msg);
+			throwf("in section %s,%s reloc %u: %s", sect->segname(), MRFSection<A>::makeSectionName(sect), r, msg);
 		}
 	}
 	
--- ld64-236.3/src/ld/passes/dtrace_dof.cpp.orig	2015-02-22 00:00:18.000000000 +0100
+++ ld64-236.3/src/ld/passes/dtrace_dof.cpp	2015-02-22 00:01:07.000000000 +0100
@@ -30,8 +30,17 @@
 
 #include <vector>
 #include <map>
+#ifdef __GLIBCXX__
+#include <tr1/unordered_map>
+#include <tr1/unordered_set>
+#define UNORDERED_MAP tr1::unordered_map
+#define UNORDERED_SET tr1::unordered_set
+#else
 #include <unordered_map>
 #include <unordered_set>
+#define UNORDERED_MAP unordered_map
+#define UNORDERED_SET unordered_set
+#endif
 
 #include "ld.hpp"
 #include "MachOFileAbstraction.hpp"
@@ -111,8 +120,8 @@
 	uint32_t						offset;
 	const char*						probeName;
 };
-typedef std::unordered_map<const char*, std::vector<DTraceProbeInfo>, CStringHash, CStringEquals>	ProviderToProbes;
-typedef	std::unordered_set<const char*, CStringHash, CStringEquals>  CStringSet;
+typedef std::UNORDERED_MAP<const char*, std::vector<DTraceProbeInfo>, CStringHash, CStringEquals>	ProviderToProbes;
+typedef	std::UNORDERED_SET<const char*, CStringHash, CStringEquals>  CStringSet;
 
 
 
--- ld64-236.3/src/ld/passes/order.cpp.orig	2014-04-05 00:42:29.000000000 +0200
+++ ld64-236.3/src/ld/passes/order.cpp	2015-02-22 00:01:07.000000000 +0100
@@ -32,7 +32,13 @@
 #include <vector>
 #include <map>
 #include <set>
+#ifdef __GLIBCXX__
+#include <tr1/unordered_map>
+#define UNORDERED_MAP tr1::unordered_map
+#else
 #include <unordered_map>
+#define UNORDERED_MAP unordered_map
+#endif
 
 #include "ld.hpp"
 #include "order.h"
@@ -84,7 +90,7 @@
 		const Layout&	_layout;
 	};
 				
-	typedef std::unordered_map<const char*, const ld::Atom*, CStringHash, CStringEquals> NameToAtom;
+	typedef std::UNORDERED_MAP<const char*, const ld::Atom*, CStringHash, CStringEquals> NameToAtom;
 	
 	typedef std::map<const ld::Atom*, const ld::Atom*> AtomToAtom;
 	
--- ld64-236.3/src/ld/Resolver.h.orig	2015-02-22 00:00:18.000000000 +0100
+++ ld64-236.3/src/ld/Resolver.h	2015-02-22 00:01:07.000000000 +0100
@@ -42,7 +42,13 @@
 #include <mach-o/dyld.h>
 
 #include <vector>
+#ifdef __GLIBCXX__
+#include <tr1/unordered_set>
+#define UNORDERED_SET tr1::unordered_set
+#else
 #include <unordered_set>
+#define UNORDERED_SET unordered_set
+#endif
 
 #include "Options.h"
 #include "ld.hpp"
@@ -104,7 +110,7 @@
 	void					doLinkerOption(const std::vector<const char*>& linkerOption, const char* fileName);
 	void					dumpAtoms();
 
-	typedef std::unordered_set<const char*, CStringHash, CStringEquals>  StringSet;
+	typedef std::UNORDERED_SET<const char*, CStringHash, CStringEquals>  StringSet;
 
 	class NotLive {
 	public:
--- ld64-236.3/src/ld/SymbolTable.h.orig	2014-04-05 00:42:29.000000000 +0200
+++ ld64-236.3/src/ld/SymbolTable.h	2015-02-22 00:01:07.000000000 +0100
@@ -42,7 +42,13 @@
 #include <mach-o/dyld.h>
 
 #include <vector>
+#ifdef __GLIBCXX__
+#include <tr1/unordered_map>
+#define UNORDERED_MAP tr1::unordered_map
+#else
 #include <unordered_map>
+#define UNORDERED_MAP unordered_map
+#endif
 
 #include "Options.h"
 #include "ld.hpp"
@@ -57,38 +63,38 @@
 	typedef uint32_t IndirectBindingSlot;
 
 private:
-	typedef std::unordered_map<const char*, IndirectBindingSlot, CStringHash, CStringEquals> NameToSlot;
+	typedef std::UNORDERED_MAP<const char*, IndirectBindingSlot, CStringHash, CStringEquals> NameToSlot;
 
 	class ContentFuncs {
 	public:
 		size_t	operator()(const ld::Atom*) const;
 		bool	operator()(const ld::Atom* left, const ld::Atom* right) const;
 	};
-	typedef std::unordered_map<const ld::Atom*, IndirectBindingSlot, ContentFuncs, ContentFuncs> ContentToSlot;
+	typedef std::UNORDERED_MAP<const ld::Atom*, IndirectBindingSlot, ContentFuncs, ContentFuncs> ContentToSlot;
 
 	class ReferencesHashFuncs {
 	public:
 		size_t	operator()(const ld::Atom*) const;
 		bool	operator()(const ld::Atom* left, const ld::Atom* right) const;
 	};
-	typedef std::unordered_map<const ld::Atom*, IndirectBindingSlot, ReferencesHashFuncs, ReferencesHashFuncs> ReferencesToSlot;
+	typedef std::UNORDERED_MAP<const ld::Atom*, IndirectBindingSlot, ReferencesHashFuncs, ReferencesHashFuncs> ReferencesToSlot;
 
 	class CStringHashFuncs {
 	public:
 		size_t	operator()(const ld::Atom*) const;
 		bool	operator()(const ld::Atom* left, const ld::Atom* right) const;
 	};
-	typedef std::unordered_map<const ld::Atom*, IndirectBindingSlot, CStringHashFuncs, CStringHashFuncs> CStringToSlot;
+	typedef std::UNORDERED_MAP<const ld::Atom*, IndirectBindingSlot, CStringHashFuncs, CStringHashFuncs> CStringToSlot;
 
 	class UTF16StringHashFuncs {
 	public:
 		size_t	operator()(const ld::Atom*) const;
 		bool	operator()(const ld::Atom* left, const ld::Atom* right) const;
 	};
-	typedef std::unordered_map<const ld::Atom*, IndirectBindingSlot, UTF16StringHashFuncs, UTF16StringHashFuncs> UTF16StringToSlot;
+	typedef std::UNORDERED_MAP<const ld::Atom*, IndirectBindingSlot, UTF16StringHashFuncs, UTF16StringHashFuncs> UTF16StringToSlot;
 
 	typedef std::map<IndirectBindingSlot, const char*> SlotToName;
-	typedef std::unordered_map<const char*, CStringToSlot*, CStringHash, CStringEquals> NameToMap;
+	typedef std::UNORDERED_MAP<const char*, CStringToSlot*, CStringHash, CStringEquals> NameToMap;
     
     typedef std::vector<const ld::Atom *> DuplicatedSymbolAtomList;
     typedef std::map<const char *, DuplicatedSymbolAtomList * > DuplicateSymbols;
--- ld64-236.3/src/other/dyldinfo.cpp.orig	2015-02-22 00:00:18.000000000 +0100
+++ ld64-236.3/src/other/dyldinfo.cpp	2015-02-22 00:01:07.000000000 +0100
@@ -33,7 +33,6 @@
 
 #include <vector>
 #include <set>
-#include <unordered_set>
 
 #include "configure.h"
 #include "MachOFileAbstraction.hpp"
--- ld64-236.3/src/other/machochecker.cpp.orig	2015-02-22 00:00:18.000000000 +0100
+++ ld64-236.3/src/other/machochecker.cpp	2015-02-22 00:01:07.000000000 +0100
@@ -33,7 +33,13 @@
 
 #include <vector>
 #include <set>
+#ifdef __GLIBCXX__
+#include <tr1/unordered_set>
+#define UNORDERED_SET tr1::unordered_set
+#else
 #include <unordered_set>
+#define UNORDERED_SET unordered_set
+#endif
 
 #include "configure.h"
 
@@ -124,7 +130,7 @@
 		bool operator()(const char* left, const char* right) const { return (strcmp(left, right) == 0); }
 	};
 
-	typedef std::unordered_set<const char*, CStringHash, CStringEquals>  StringSet;
+	typedef std::UNORDERED_SET<const char*, CStringHash, CStringEquals>  StringSet;
 
 												MachOChecker(const uint8_t* fileContent, uint32_t fileLength, const char* path);
 	void										checkMachHeader();
--- ld64-236.3/src/other/unwinddump.cpp.orig	2015-02-22 00:00:18.000000000 +0100
+++ ld64-236.3/src/other/unwinddump.cpp	2015-02-22 00:01:07.000000000 +0100
@@ -33,7 +33,6 @@
 
 #include <vector>
 #include <set>
-#include <unordered_set>
 
 #include "configure.h"
 #include "MachOFileAbstraction.hpp"
